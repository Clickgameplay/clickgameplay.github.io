<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>you clicked (haha get it) </title>
  <style>
    /* as i am NOT a professional like i mentioned in the original homepage, this whole html site is generated by mr. chatgpt! */
    /* as i am NOT a professional like i mentioned in the original homepage, this whole html site is generated by mr. chatgpt! */
    /* as i am NOT a professional like i mentioned in the original homepage, this whole html site is generated by mr. chatgpt! */
    /* as i am NOT a professional like i mentioned in the original homepage, this whole html site is generated by mr. chatgpt! */
    /* as i am NOT a professional like i mentioned in the original homepage, this whole html site is generated by mr. chatgpt! */
    /* as i am NOT a professional like i mentioned in the original homepage, this whole html site is generated by mr. chatgpt! */
    /* as i am NOT a professional like i mentioned in the original homepage, this whole html site is generated by mr. chatgpt! */
    /* as i am NOT a professional like i mentioned in the original homepage, this whole html site is generated by mr. chatgpt! */
    /* as i am NOT a professional like i mentioned in the original homepage, this whole html site is generated by mr. chatgpt! */
    /* as i am NOT a professional like i mentioned in the original homepage, this whole html site is generated by mr. chatgpt! */
    /* as i am NOT a professional like i mentioned in the original homepage, this whole html site is generated by mr. chatgpt! */
    /* as i am NOT a professional like i mentioned in the original homepage, this whole html site is generated by mr. chatgpt! */
    /* as i am NOT a professional like i mentioned in the original homepage, this whole html site is generated by mr. chatgpt! */
    /* as i am NOT a professional like i mentioned in the original homepage, this whole html site is generated by mr. chatgpt! */
    /* as i am NOT a professional like i mentioned in the original homepage, this whole html site is generated by mr. chatgpt! */
    /* as i am NOT a professional like i mentioned in the original homepage, this whole html site is generated by mr. chatgpt! */
    /* as i am NOT a professional like i mentioned in the original homepage, this whole html site is generated by mr. chatgpt! */
    /* as i am NOT a professional like i mentioned in the original homepage, this whole html site is generated by mr. chatgpt! */
    /* as i am NOT a professional like i mentioned in the original homepage, this whole html site is generated by mr. chatgpt! */
    /* as i am NOT a professional like i mentioned in the original homepage, this whole html site is generated by mr. chatgpt! */
    /* as i am NOT a professional like i mentioned in the original homepage, this whole html site is generated by mr. chatgpt! */
    /* as i am NOT a professional like i mentioned in the original homepage, this whole html site is generated by mr. chatgpt! */
    /* as i am NOT a professional like i mentioned in the original homepage, this whole html site is generated by mr. chatgpt! */
    /* as i am NOT a professional like i mentioned in the original homepage, this whole html site is generated by mr. chatgpt! */
    /* as i am NOT a professional like i mentioned in the original homepage, this whole html site is generated by mr. chatgpt! */
    /* as i am NOT a professional like i mentioned in the original homepage, this whole html site is generated by mr. chatgpt! */
    /* as i am NOT a professional like i mentioned in the original homepage, this whole html site is generated by mr. chatgpt! */
    /* as i am NOT a professional like i mentioned in the original homepage, this whole html site is generated by mr. chatgpt! */
    /* as i am NOT a professional like i mentioned in the original homepage, this whole html site is generated by mr. chatgpt! */
    /* as i am NOT a professional like i mentioned in the original homepage, this whole html site is generated by mr. chatgpt! */
    /* as i am NOT a professional like i mentioned in the original homepage, this whole html site is generated by mr. chatgpt! */
    /* as i am NOT a professional like i mentioned in the original homepage, this whole html site is generated by mr. chatgpt! */
    /* as i am NOT a professional like i mentioned in the original homepage, this whole html site is generated by mr. chatgpt! */
    /* as i am NOT a professional like i mentioned in the original homepage, this whole html site is generated by mr. chatgpt! */
    /* i am spamming this so people get attention, not to get lag spiked btw */
    html,body{height:100%;margin:0;background:#111;color:#eee;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial}
    #gameWrap{position:relative;width:100%;height:100vh;display:flex;align-items:center;justify-content:center}
    canvas{background:#222;display:block;max-width:100%;height:auto;border-radius:8px;box-shadow:0 8px 30px rgba(0,0,0,.8)}

    /* On-screen controls */
    .controls{position: absolute;left:12px;bottom:12px;display:none;gap:6px}
    .pad{display:grid;grid-template-columns:repeat(3,64px);grid-template-rows:repeat(3,64px);gap:6px}
    .btn{width:64px;height:64px;border-radius:12px;background:rgba(255,255,255,0.06);display:flex;align-items:center;justify-content:center;user-select:none;touch-action:none}
    .btn:active{transform:scale(.96)}
    .hidden-cell{visibility:hidden}

    /* Jumpscare overlay */
    #jumpscare{
      position:fixed;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      background:black;
      z-index:9999;
      flex-direction:column;
      gap:18px;
      padding:20px;
      box-sizing:border-box;
    }
    #jumpscare .panel{
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:12px;
      max-width:100%;
      width:min(900px,95%);
    }

    /* Use CSS variables for rotation & scale so JS can update --rot while CSS still runs pop animation */
    #jumpscare img{
      --rot: 0deg;
      --scale: 1;
      max-width:100%;
      max-height:70vh;
      object-fit:contain;
      transform: rotate(var(--rot)) scale(var(--scale));
      animation:pop .45s cubic-bezier(.2,.9,.2,1);
      transition: filter .12s;
    }

    @keyframes pop{
      0%{ --scale: .6; --rot: -6deg; filter:brightness(.2) }
      50%{ --scale: 1.05; --rot: 6deg; filter:brightness(1.2) }
      100%{ --scale: 1; --rot: 0deg; filter:brightness(1) }
    }

    #jumpscare .text{color:#fff;text-align:center;font-size:1rem}
    #jumpscare .credit{color:#ddd;font-size:.9rem;opacity:.9}
    #jumpscare .actions{display:flex;gap:12px;flex-wrap:wrap;justify-content:center}

    .link-btn{background:#b21;color:#fff;border:none;padding:10px 14px;border-radius:6px;text-decoration:none;cursor:pointer}
    .neutral-btn{background:#333;color:#fff;border:none;padding:10px 14px;border-radius:6px;cursor:pointer}

    /* UI overlay */
    #ui{position:absolute;right:12px;top:12px;background:rgba(0,0,0,0.4);padding:8px;border-radius:8px}
    button{background:#222;color:#eee;border:1px solid rgba(255,255,255,0.06);padding:6px 10px;border-radius:6px}

    /* Make pad visible on touch devices */
    @media (pointer:coarse){.controls{display:block}}
  </style>
</head>
<body>
  <div id="gameWrap">
    <canvas id="c"></canvas>

    <div class="controls" id="controls">
      <div class="pad">
        <div class="hidden-cell"></div>
        <div class="btn" data-dir="up">▲</div>
        <div class="hidden-cell"></div>

        <div class="btn" data-dir="left">◀</div>
        <div class="btn" data-dir="down">▼</div>
        <div class="btn" data-dir="right">▶</div>
      </div>
    </div>

    <div id="ui">
      <div style="margin-bottom:6px">Use arrow keys or on-screen pad</div>
      <button id="restart">Restart</button>
      <button id="mute">Mute</button>
    </div>
  </div>

  <!-- Jumpscare overlay (hidden until triggered) -->
  <div id="jumpscare" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="panel">
      <img id="jumpImg" src="click_funi.png" alt="jumpscare">
      <div class="text">(Voiced by plague.1, not by me)</div>
      <div class="actions">
        <a id="homeBtn" class="link-btn" href="https://clickgameplay.github.io" target="_blank" rel="noopener noreferrer">Go to homepage</a>
        <button id="replayBtn" class="neutral-btn">Play again</button>
      </div>
    </div>
  </div>

  <script>
  /*
    IMPORTANT:
    - Place the files sticcman.png, click_funi.png and scary_real.mp3 in the same folder as this HTML file.
    - This version adds audio-driven rotation to the jumpscare image while scary_real.mp3 is playing.
      It uses an AnalyserNode to read audio amplitude and maps it to a rotation angle for a "radio/voice" feel.
  */

  (function(){
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');
    const controls = document.getElementById('controls');
    const restartBtn = document.getElementById('restart');
    const muteBtn = document.getElementById('mute');
    const jumpscare = document.getElementById('jumpscare');
    const jumpImg = document.getElementById('jumpImg');
    const homeBtn = document.getElementById('homeBtn');
    const replayBtn = document.getElementById('replayBtn');

    let mute = false;

    // Assets
    const playerImg = new Image(); playerImg.src = 'sticcman.png';
    const scareAudio = new Audio('scary_real.mp3');
    scareAudio.preload = 'auto';

    // Web Audio API elements for analyzing audio amplitude
    let audioCtx = null;
    let analyser = null;
    let sourceNode = null;
    let dataArray = null;
    let analyserRaf = null;

    // Map (0 = floor, 1 = wall, 2 = goal)
    // Simple handcrafted maze (15 rows x 21 cols)
    const MAP = [
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
      [1,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,1],
      [1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,1,1,0,1],
      [1,0,1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,1],
      [1,0,1,0,1,1,1,1,0,1,1,1,0,1,0,1,1,0,1,0,1],
      [1,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1],
      [1,1,1,1,1,1,0,1,1,1,0,1,1,1,0,1,0,1,1,0,1],
      [1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,0,0,0,1],
      [1,0,1,1,0,1,1,1,0,1,1,1,0,1,0,1,1,1,1,0,1],
      [1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,0,1],
      [1,1,0,1,1,1,0,1,1,1,0,1,1,1,1,1,1,0,1,0,1],
      [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,1,0,1],
      [1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,0,1,0,1],
      [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,1],
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
    ];

    const ROWS = MAP.length;
    const COLS = MAP[0].length;

    // Player state (grid coordinate + position in pixels)
    const start = {r:1,c:1};
    const goal = findGoal(MAP);

    let tileSize = 32;
    let player = {x: start.c + .5, y: start.r + .5, speed: 4.5}; // x,y are in tile units
    let keys = {left:false,right:false,up:false,down:false};
    let last = performance.now();
    let reached = false;

    // Resize canvas to available space while preserving grid aspect
    function resize(){
      const wrap = document.getElementById('gameWrap');
      const maxW = Math.min(window.innerWidth - 24, 1100);
      const maxH = Math.min(window.innerHeight - 24, 800);
      tileSize = Math.floor(Math.min(maxW / COLS, maxH / ROWS));
      canvas.width = tileSize * COLS;
      canvas.height = tileSize * ROWS;
      canvas.style.width = canvas.width + 'px';
      canvas.style.height = canvas.height + 'px';
    }

    window.addEventListener('resize', resize);

    // Input handlers
    window.addEventListener('keydown', e=>{
      if(e.key==='ArrowLeft' || e.key==='a') keys.left = true;
      if(e.key==='ArrowRight' || e.key==='d') keys.right = true;
      if(e.key==='ArrowUp' || e.key==='w') keys.up = true;
      if(e.key==='ArrowDown' || e.key==='s') keys.down = true;
    });
    window.addEventListener('keyup', e=>{
      if(e.key==='ArrowLeft' || e.key==='a') keys.left = false;
      if(e.key==='ArrowRight' || e.key==='d') keys.right = false;
      if(e.key==='ArrowUp' || e.key==='w') keys.up = false;
      if(e.key==='ArrowDown' || e.key==='s') keys.down = false;
    });

    // Touch pad buttons
    controls.querySelectorAll('.btn').forEach(btn=>{
      const dir = btn.dataset.dir;
      const mapping = {left:'left',right:'right',up:'up',down:'down'};
      btn.addEventListener('pointerdown', e=>{ e.preventDefault(); keys[mapping[dir]] = true; });
      btn.addEventListener('pointerup', e=>{ e.preventDefault(); keys[mapping[dir]] = false; });
      btn.addEventListener('pointerleave', e=>{ e.preventDefault(); keys[mapping[dir]] = false; });
      btn.addEventListener('touchcancel', e=>{ keys[mapping[dir]] = false; });
    });

    // Restart & mute
    restartBtn.addEventListener('click', restart);
    muteBtn.addEventListener('click', ()=>{ mute = !mute; muteBtn.textContent = mute? 'Unmute' : 'Mute'; if(mute) scareAudio.pause(); });

    // Home & replay buttons handlers
    // homeBtn is an anchor so default behavior opens in new tab
    replayBtn.addEventListener('click', ()=>{
      // hide overlay and restart
      hideJumpscare();
      restart();
    });

    function restart(){
      player.x = start.c + .5; player.y = start.r + .5; reached = false; hideJumpscare(); if(!mute){try{scareAudio.pause(); scareAudio.currentTime=0;}catch(e){}}
    }

    function findGoal(map){
      for(let r=0;r<map.length;r++) for(let c=0;c<map[0].length;c++) if(map[r][c]===2) return {r,c};
      return {r:ROWS-2,c:COLS-2};
    }

    function isWallAt(col,row){
      if(row<0||row>=ROWS||col<0||col>=COLS) return true; return MAP[row][col]===1;
    }

    // Basic collision using AABB with circle (player treated as circle) in tile units
    function movePlayer(dx,dy,dt){
      // proposed
      let nx = player.x + dx*player.speed*dt;
      let ny = player.y + dy*player.speed*dt;
      const radius = 0.28; // in tiles

      // Check four sample points around circle — conservative approach
      // We'll clamp movement separately on x and y for simplicity
      // X axis
      if(!collides(nx, player.y, radius)) player.x = nx;
      else {
        // try small step to slide
      }
      // Y axis
      if(!collides(player.x, ny, radius)) player.y = ny;

      // Check goal
      const pr = Math.floor(player.y);
      const pc = Math.floor(player.x);
      if(MAP[pr][pc]===2 && !reached){
        reached = true; triggerJumpscare();
      }
    }

    function collides(cx,cy,r){
      // check tiles overlapping circle
      const minC = Math.floor(cx - r);
      const maxC = Math.floor(cx + r);
      const minR = Math.floor(cy - r);
      const maxR = Math.floor(cy + r);
      for(let rr=minR; rr<=maxR; rr++){
        for(let cc=minC; cc<=maxC; cc++){
          if(isWallAt(cc,rr)){
            // circle vs square collision
            const nearestX = Math.max(cc, Math.min(cx, cc+1));
            const nearestY = Math.max(rr, Math.min(cy, rr+1));
            const dx = cx - nearestX;
            const dy = cy - nearestY;
            if(dx*dx + dy*dy < r*r) return true;
          }
        }
      }
      return false;
    }

    // Audio analyser setup and processing
    function initAudioAnalyser(){
      if(audioCtx) return;
      try {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        sourceNode = audioCtx.createMediaElementSource(scareAudio);
        analyser = audioCtx.createAnalyser();
        analyser.fftSize = 2048;
        sourceNode.connect(analyser);
        analyser.connect(audioCtx.destination);
        dataArray = new Uint8Array(analyser.fftSize);
      } catch (e) {
        console.warn('Web Audio API not available:', e);
        audioCtx = null;
      }
    }

    function startAnalyserLoop(){
      if(!analyser || !dataArray) return;
      cancelAnalyserLoop();
      function tick(){
        analyser.getByteTimeDomainData(dataArray);
        // compute RMS-like loudness (normalize 0..1)
        let sum = 0;
        for(let i=0;i<dataArray.length;i++){
          const v = (dataArray[i] - 128) / 128; // -1..1
          sum += v * v;
        }
        const rms = Math.sqrt(sum / dataArray.length); // 0..1
        // map rms to rotation amplitude (deg)
        const maxAngle = 18; // maximum rotation amplitude in degrees
        // Add a fast oscillation so it "shakes" while audio speaks; oscillation frequency in Hz
        const now = performance.now() / 1000;
        const osc = Math.sin(now * 20); // 20 rad/s => ~3 Hz
        const angle = (rms * maxAngle) * osc; // -max..+max scaled by current loudness

        // update CSS variable --rot on the image
        jumpImg.style.setProperty('--rot', angle.toFixed(2) + 'deg');

        // slightly brighten image when loud
        const bright = 1 + Math.min(0.6, rms * 2.2);
        jumpImg.style.filter = `brightness(${bright})`;

        analyserRaf = requestAnimationFrame(tick);
      }
      analyserRaf = requestAnimationFrame(tick);
    }

    function cancelAnalyserLoop(){
      if(analyserRaf) cancelAnimationFrame(analyserRaf);
      analyserRaf = null;
      // reset visual variables
      if(jumpImg){
        jumpImg.style.setProperty('--rot', '0deg');
        jumpImg.style.filter = '';
      }
    }

    function shutdownAnalyser(){
      cancelAnalyserLoop();
      try {
        if(sourceNode){ sourceNode.disconnect(); sourceNode = null; }
        if(analyser){ analyser.disconnect(); analyser = null; }
        if(audioCtx && audioCtx.state !== 'closed'){ /* don't close context to avoid recreate issues */ }
      } catch(e){}
    }

    function triggerJumpscare(){
      // Show full-screen image and play audio
      jumpscare.style.display = 'flex';
      jumpscare.setAttribute('aria-hidden','false');

      // prepare audio analyser
      initAudioAnalyser();
      // try to play sound — browsers allow play if triggered by user interaction (movement counts on many browsers)
      if(!mute){
        // ensure audio context resumed on user gesture (some browsers require resume)
        if(audioCtx && audioCtx.state === 'suspended'){ audioCtx.resume().catch(()=>{}); }
        try{
          scareAudio.currentTime = 0;
          const p = scareAudio.play();
          if(p && typeof p.then === 'function'){
            p.then(()=> {
              // start analyser loop only after play allowed
              if(analyser) startAnalyserLoop();
            }).catch(()=> {
              // play blocked -> user can press Play again (replay button) to trigger
            });
          } else {
            if(analyser) startAnalyserLoop();
          }
        } catch(e){}
      }

      // on ended or pause, stop analyser and reset rotation
      scareAudio.onended = scareAudio.onpause = function(){
        cancelAnalyserLoop();
      };
    }

    function hideJumpscare(){
      jumpscare.style.display = 'none';
      jumpscare.setAttribute('aria-hidden','true');
      try{ scareAudio.pause(); scareAudio.currentTime = 0; }catch(e){}
      cancelAnalyserLoop();
    }

    function draw(){
      ctx.clearRect(0,0,canvas.width,canvas.height);

      // draw map
      for(let r=0;r<ROWS;r++){
        for(let c=0;c<COLS;c++){
          const x = c*tileSize, y = r*tileSize;
          if(MAP[r][c]===1){
            ctx.fillStyle = '#111';
            ctx.fillRect(x,y,tileSize,tileSize);

            // wall texture (simple)
            ctx.fillStyle = '#0b0b0b';
            ctx.fillRect(x+2,y+2,tileSize-4,tileSize-4);
          } else if(MAP[r][c]===2){
            ctx.fillStyle = '#153';
            ctx.fillRect(x,y,tileSize,tileSize);
            ctx.fillStyle = '#2fd';
            ctx.fillRect(x+tileSize*0.15,y+tileSize*0.15,tileSize*0.7,tileSize*0.7);
          } else {
            // floor
            ctx.fillStyle = '#282828';
            ctx.fillRect(x,y,tileSize,tileSize);
          }
        }
      }

      // draw player centered
      const px = player.x*tileSize;
      const py = player.y*tileSize;
      const pW = tileSize*0.8, pH = tileSize*0.8;
      const img = playerImg.complete && playerImg.naturalWidth>0 ? playerImg : null;
      if(img){
        ctx.drawImage(img, px - pW/2, py - pH/2, pW, pH);
      } else {
        ctx.fillStyle = '#ffeb3b'; ctx.beginPath(); ctx.arc(px,py,tileSize*0.28,0,Math.PI*2); ctx.fill();
      }

      // optional HUD
      if(reached){
        ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(0,0,canvas.width,canvas.height);
      }
    }

    function loop(now){
      const dt = Math.min(0.05, (now - last)/1000); last = now;
      // compute movement vector
      let dx = 0, dy = 0;
      if(keys.left) dx -= 1; if(keys.right) dx += 1; if(keys.up) dy -= 1; if(keys.down) dy += 1;
      // normalize
      if(dx!==0 || dy!==0){
        const len = Math.sqrt(dx*dx + dy*dy); dx/=len; dy/=len;
        movePlayer(dx,dy,dt);
      }
      draw();
      requestAnimationFrame(loop);
    }

    // initial setup
    resize();
    restart();
    last = performance.now();
    requestAnimationFrame(loop);

    // show controls on touch devices
    if('ontouchstart' in window || navigator.maxTouchPoints>0) controls.style.display='block';

    // Helpful: on first user interaction, unlock audio on some browsers
    function unlockAudio(){ 
      try{ 
        if(!audioCtx) initAudioAnalyser();
        if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume().catch(()=>{});
        // try play/pause to prime audio autoplay permissions
        scareAudio.play().then(()=>{ scareAudio.pause(); scareAudio.currentTime = 0; }).catch(()=>{});
      }catch(e){}
      window.removeEventListener('pointerdown', unlockAudio); 
      window.removeEventListener('touchstart', unlockAudio); 
    }
    window.addEventListener('pointerdown', unlockAudio);
    window.addEventListener('touchstart', unlockAudio);

  })();
  </script>
</body>
</html>
